# -*- coding: utf-8 -*-
"""task3_pclub.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PRWFlsnE4ky9D9ul67V14LhvyVOnp9lh
"""

import pandas as pd
chem = pd.read_csv("/new_dataset.csv")
print(chem.head())

X = chem.drop('frac_similar', axis = 1)
y = chem['frac_similar']

print(chem.info())
print(chem.columns)

!pip install rdkit

from rdkit import Chem
from rdkit.Chem import AllChem, DataStructs
import numpy as np

def smiles_to_fingerprint(smiles, radius=2, n_bits=1024):
    mol = Chem.MolFromSmiles(smiles)
    if mol:

        fingerprint = AllChem.GetMorganFingerprintAsBitVect(mol, radius, nBits=n_bits)
        return fingerprint
    else:
        return None


def tanimoto_similarity(fingerprint1, fingerprint2):
    if fingerprint1 and fingerprint2:
        return DataStructs.FingerprintSimilarity(fingerprint1, fingerprint2)
    else:
        return None

smiles_1 = chem['curated_smiles_molecule_a']
smiles_2 = chem['curated_smiles_molecule_b']

fingerprints_1 = [smiles_to_fingerprint(s) for s in smiles_1]
fingerprints_2 = [smiles_to_fingerprint(s) for s in smiles_2]

similarities = [tanimoto_similarity(f1, f2) for f1, f2 in zip(fingerprints_1, fingerprints_2)]

chem['predicted_similarity'] = similarities

X = chem[['predicted_similarity']]
y = chem['frac_similar']

from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score

X_train, X_test, y_train, y_test = train_test_split(X,y, test_size = 0.2, random_state = 42)
model = RandomForestRegressor(n_estimators = 100, random_state = 42)
model.fit(X_train, y_train)

y_pred = model.predict(X_test)

mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

print(f"Mean Squared Error: {mse}")
print(f"R-squared: {r2}")

import matplotlib.pyplot as plt
plt.scatter(y_test, y_pred)
plt.plot([min(y_test), max(y_test)], [min(y_test), max(y_test)], color='red', linestyle='--')
plt.xlabel('Actual Similarity')
plt.ylabel('Predicted Similarity')
plt.title('Actual vs Predicted Similarity')
plt.show()